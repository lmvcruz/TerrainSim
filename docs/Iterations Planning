Implementation Roadmap (Iterative Development)

The project follows an iterative development model, with each iteration delivering a functional, testable increment that builds upon the previous iteration. This approach ensures continuous integration, early feedback, and incremental complexity growth.

---

### **Iteration 1: Foundation & Basic Visualization**
**Goal:** Establish the core infrastructure and render a simple, static heightmap.

**Backend Deliverables:**
*   Set up Monorepo structure with pnpm workspaces.
*   Configure CI/CD pipeline (GitHub Actions) with basic linting and test runners.
*   Implement a simple `Heightmap` class in C++ (`libs/core`):
    *   Fixed-size 2D grid (e.g., 256Ã—256).
    *   Generic data container with no initialization strategies built-in.
    *   Basic getters/setters for grid access.
*   Create `TerrainGenerators` module with factory functions:
    *   `generateSemiSphere()` - Hemisphere shape for testing
    *   `generateCone()` - Conical peak
    *   `generateSigmoid()` - Smooth transition surface
    *   These functions create and return configured Heightmap instances
*   Write initial GoogleTest suite for `Heightmap` class (boundary checks, memory layout).

**Design Note:** The Heightmap class is intentionally kept generic and free of initialization logic. Terrain generation strategies (semi-sphere, cone, noise, etc.) are implemented as separate factory functions in the TerrainGenerators module. This separation maintains single responsibility and allows easy extension of generation methods without modifying the core Heightmap class.

**Frontend Deliverables:**
*   Set up React + Vite + TypeScript project (`apps/web`).
*   Implement basic R3F terrain component:
    *   Plane geometry with vertex displacement shader.
    *   Load heightmap data from a static Float32Array.
    *   Simple grayscale or single-color material.
*   Add orbit controls for camera navigation.
*   Display a flat or manually defined heightmap (e.g., a pyramid or ramp).

**Integration:**
*   No API yet; frontend uses hardcoded heightmap data for testing.

**Tasks:**
- [x] **INFRA-001:** Initialize pnpm-workspace.yaml and root package.json
- [x] **INFRA-002:** Set up GitHub Actions workflow (build + test jobs)
- [x] **INFRA-003:** Configure linting tools (ESLint for TS, clang-format for C++)
- [x] **CORE-001:** Create Heightmap class with 2D grid storage (Row-Major Order)
- [x] **CORE-002:** Create TerrainGenerators module with factory functions (semi-sphere, cone, sigmoid)
- [x] **CORE-003:** Add getter/setter methods (at(), set(), width(), height())
- [x] **CORE-004:** Write GoogleTest suite (10+ test cases)
- [x] **CORE-005:** Add CMakeLists.txt with GoogleTest integration
- [x] **WEB-001:** Scaffold React + Vite + TypeScript app (apps/web)
- [x] **WEB-002:** Install Three.js and React Three Fiber dependencies
- [x] **WEB-003:** Create TerrainMesh component with PlaneGeometry
- [x] **WEB-004:** Implement vertex displacement shader (basic GLSL)
- [x] **WEB-005:** Add OrbitControls for camera navigation
- [x] **WEB-006:** Load hardcoded Float32Array heightmap data
- [x] **TEST-001:** Verify CI pipeline passes all checks
- [x] **TEST-002:** Manual test: Render semi-sphere in 3D viewport
- [x] **DEPLOY-001:** Configure GitHub Pages deployment with GitHub Actions
- [x] **DOC-001:** Update README with build and run instructions

**Success Criteria:**
*   CI pipeline runs successfully (build + tests pass).
*   3D viewport renders a simple terrain mesh.
*   User can rotate, pan, and zoom the camera.

---

### **Iteration 1.5: Testing & Debugging Infrastructure**
**Goal:** Establish comprehensive testing, logging, and debugging capabilities to support rapid development and AI-assisted debugging.

**Backend Deliverables:**
*   Set up development log endpoints (`/dev/logs`):
    *   POST endpoint to receive browser logs from frontend.
    *   GET endpoint with filtering (level, component, timestamp, limit).
    *   DELETE endpoint to clear logs.
    *   File-based storage in `.dev-logs/browser-logs.json` (max 5000 entries).
*   Configure backend for CORS with DELETE method support.

**Frontend Deliverables:**
*   Achieve >85% test coverage for critical components:
    *   Install `@vitest/coverage-v8` for code coverage reporting.
    *   Write comprehensive tests for `App.tsx` state management.
    *   Add 14 tests for `TerrainMesh.tsx` component (texture updates, prop changes, lifecycle).
    *   Mock Three.js objects for JSDOM environment.
*   Implement centralized logging system:
    *   Create `Logger` class with log levels (debug, info, warn, error).
    *   Add component-scoped loggers (e.g., `TerrainMesh`, `App`).
    *   Implement log groups for related operations.
    *   Add performance timing utilities (`logger.time()`, `logger.timeAsync()`, `logger.measure()`).
    *   Replace all `console.log` calls with structured logging.
*   Create `LogCollector` for development:
    *   Capture all logs in memory with filtering capabilities.
    *   Auto-save to localStorage every 5 seconds.
    *   Provide `window.downloadLogs()` for manual export.
    *   Auto-send logs to backend every 30 seconds (if available).
    *   Graceful degradation when backend unavailable.
*   Set up Playwright for E2E and visual regression testing:
    *   Install Playwright with Chromium browser.
    *   Create functional E2E tests (app load, API connection, console errors).
    *   Implement visual regression test with baseline screenshots.
    *   Configure generous diff tolerances for WebGL rendering (maxDiffPixels: 1000).
    *   Add test scripts: `test:e2e`, `test:visual`, `test:e2e:ui`, `test:visual:update`.

**Integration:**
*   Backend and frontend coordinate for log collection:
    *   Frontend checks backend health on startup.
    *   If available, enables automatic log transmission.
    *   Backend stores logs with query/filter capabilities.
    *   AI agents can retrieve logs via HTTP GET without manual user intervention.
*   CI pipeline extended with E2E tests:
    *   Step 2 in CI script runs E2E and visual tests.
    *   Auto-starts both API server and web server for tests.
    *   Visual baselines stored in version control.

**Tasks:**
- [x] **TEST-101:** Install @vitest/coverage-v8 package
- [x] **TEST-102:** Generate initial coverage report (58.15% baseline)
- [x] **TEST-103:** Write App.tsx state management tests
- [x] **TEST-104:** Create TerrainMesh.tsx comprehensive test suite (14 tests)
- [x] **TEST-105:** Implement Three.js mocking for JSDOM
- [x] **TEST-106:** Achieve 86.95% overall coverage
- [x] **LOG-001:** Create Logger class with log levels
- [x] **LOG-002:** Add component-scoped logger factory
- [x] **LOG-003:** Implement log groups for operation tracking
- [x] **LOG-004:** Add performance timing utilities
- [x] **LOG-005:** Replace all console.log with structured logging
- [x] **LOG-006:** Create LogCollector class
- [x] **LOG-007:** Implement localStorage auto-save (5s interval)
- [x] **LOG-008:** Add downloadLogs() helper function
- [x] **LOG-009:** Expose window.downloadLogs() for debugging
- [x] **API-014:** Create POST /dev/logs endpoint
- [x] **API-015:** Create GET /dev/logs endpoint with filtering
- [x] **API-016:** Create DELETE /dev/logs endpoint
- [x] **API-017:** Implement file-based log storage (max 5000 entries)
- [x] **API-018:** Add CORS support for DELETE method
- [x] **WEB-051:** Implement backend health check on startup
- [x] **WEB-052:** Enable auto-send logs every 30 seconds
- [x] **WEB-053:** Implement graceful degradation for offline mode
- [x] **E2E-001:** Install Playwright and Chromium browser
- [x] **E2E-002:** Create playwright.config.ts with auto-server startup
- [x] **E2E-003:** Write functional E2E tests (terrain.spec.ts)
- [x] **E2E-004:** Create visual regression proof-of-concept (visual-poc.spec.ts)
- [x] **E2E-005:** Generate baseline screenshots
- [x] **E2E-006:** Configure diff tolerances for WebGL rendering
- [x] **E2E-007:** Add Playwright test scripts to package.json
- [x] **E2E-008:** Integrate E2E tests into CI pipeline (Step 2)
- [x] **E2E-009:** Update .gitignore for Playwright artifacts
- [x] **DOC-007:** Create LOGGING_SYSTEM.md documentation
- [x] **DOC-008:** Create AGENT_DEBUGGING_WORKFLOW.md
- [x] **DOC-009:** Create VISUAL_REGRESSION_TESTING.md
- [x] **DOC-010:** Update TESTING_AND_DEBUGGING_IMPROVEMENTS.md roadmap

**Success Criteria:**
*   Test coverage exceeds 85% for critical frontend components.
*   All console output uses structured logging with appropriate levels.
*   AI agents can retrieve browser logs programmatically via HTTP API.
*   E2E tests run successfully in CI pipeline.
*   Visual regression tests detect unintended UI changes.
*   CI pipeline includes 5 steps: (1) Frontend Tests, (2) E2E & Visual, (3) Backend Tests, (4) Build, (5) Deploy Check.

---

### **Iteration 2: Procedural Noise Generation**
**Goal:** Add parameterized noise functions for terrain generation.

**Backend Deliverables:**
*   Implement Perlin Noise algorithm in `libs/core`:
    *   Configurable parameters: seed, frequency, amplitude.
    *   Pure function: `generatePerlinNoise(width, height, seed, frequency, amplitude) -> Heightmap`.
*   Add unit tests for noise generation (deterministic output, value ranges).
*   Implement Fractional Brownian Motion (fBm):
    *   Layered octaves of Perlin noise.
    *   Parameters: octave count, persistence, lacunarity.

**Frontend Deliverables:**
*   Add UI controls for noise generation:
    *   Seed input field.
    *   Sliders for frequency, amplitude, octaves.
    *   "Generate" button to trigger terrain creation.
*   Improve visualization:
    *   Color gradient based on elevation (low = blue, mid = green, high = white).
    *   Wireframe toggle for debugging.
*   Add basic statistics display (min/max elevation).

**Integration:**
*   Create a simple local API endpoint (e.g., HTTP server or direct WASM binding) to call C++ noise functions from the frontend.
*   Frontend sends parameters and receives heightmap as Float32Array.

**Tasks:**
- [x] **CORE-006:** Implement Perlin Noise gradient generation
- [x] **CORE-007:** Add interpolation functions (smoothstep, lerp)
- [x] **CORE-008:** Create generatePerlinNoise() function
- [x] **CORE-009:** Write unit tests for noise determinism
- [x] **CORE-010:** Implement fBm with octave layering
- [x] **CORE-011:** Add parameter validation (range checks)
- [x] **API-001:** Set up simple HTTP server (Express.js or Crow C++)
- [x] **API-002:** Create /generate endpoint accepting noise parameters
- [x] **API-003:** Serialize Heightmap to Float32Array in response
- [x] **API-004:** Add CORS support for local development
- [x] **WEB-007:** Enhance material with elevation-based color gradient
- [x] **WEB-008:** Create NoiseParametersPanel UI component
- [x] **WEB-009:** Add seed input field with validation
- [x] **WEB-010:** Implement sliders (frequency, amplitude, octaves)
- [x] **WEB-011:** Wire "Generate" button to API call
- [x] **WEB-012:** Implement elevation-based color gradient shader
- [x] **WEB-013:** Add wireframe toggle button
- [x] **WEB-014:** Create StatisticsPanel component (min/max elevation)
- [x] **WEB-015:** Handle loading states and error messages
- [x] **TEST-003:** Verify same seed produces identical terrain
- [x] **TEST-004:** Test different parameter combinations
- [x] **DOC-002:** Document API endpoints and parameters

**Success Criteria:**
*   User can generate varied terrains by adjusting noise parameters.
*   Different seeds produce reproducible but distinct terrains.
*   Color-coded elevation provides visual feedback.

---

### **Iteration 2.5: Cloudflare Production Deployment**
**Goal:** Deploy frontend and backend to Cloudflare infrastructure with automated CI/CD from GitHub.

**Architecture Overview:**
*   **Frontend:** Deployed to Cloudflare Pages (static site hosting)
*   **Backend API:** Deployed to external server (VM/Container) due to native Node-API addon requirements
    *   Native C++ binding cannot run on Cloudflare Workers (no native module support)
    *   Options: Cloudflare-compatible VM service, cloud VM (AWS/GCP/Azure), or dedicated server
*   **CI/CD:** GitHub Actions workflows for automated deployment
*   **Domain:** Custom domain configured through Cloudflare DNS

**Frontend Deliverables (Cloudflare Pages):**
*   Configure Cloudflare Pages project for React + Vite app.
*   Set up build configuration:
    *   Build command: `pnpm --filter @terrain/web run build`
    *   Output directory: `apps/web/dist`
    *   Node.js version: 20.x
*   Configure environment variables:
    *   `VITE_API_URL`: Backend API endpoint
    *   `VITE_WS_URL`: WebSocket server endpoint
*   Set up custom domain with SSL/TLS.
*   Configure caching and performance optimization.

**Backend Deliverables:**
*   Set up server infrastructure:
    *   Choose deployment platform (VM with Node.js + C++ compiler support)
    *   Install system dependencies: Node.js 20+, CMake 3.15+, C++ compiler (gcc/g++)
    *   Set up process manager (PM2) for Node.js app
*   Build and deploy process:
    *   Build C++ native addon during deployment
    *   Install Node.js dependencies
    *   Configure environment variables
    *   Set up SSL/TLS certificates (Let's Encrypt)
*   Configure reverse proxy (nginx):
    *   HTTP â†’ redirect to HTTPS
    *   WebSocket upgrade headers
    *   CORS configuration for Cloudflare Pages domain
*   Set up monitoring and logging:
    *   Application logs
    *   Error tracking
    *   Health check endpoint monitoring

**GitHub Actions Workflows:**
*   Create deployment workflow for frontend (Cloudflare Pages):
    *   Trigger: Push to `main` branch (frontend changes)
    *   Deploy via Cloudflare API or Wrangler CLI
    *   Run build and deploy steps
    *   Post-deployment smoke tests
*   Create deployment workflow for backend:
    *   Trigger: Push to `main` branch (backend changes)
    *   SSH deploy to server or container registry push
    *   Build native addon on server
    *   Restart application with zero downtime
    *   Health check validation

**Domain & DNS Configuration:**
*   Configure Cloudflare DNS:
    *   A record for frontend (e.g., `terrainsim.yourdomain.com` â†’ Cloudflare Pages)
    *   A/CNAME record for API (e.g., `api.terrainsim.yourdomain.com` â†’ Backend server IP)
    *   A/CNAME record for WebSocket (e.g., `ws.terrainsim.yourdomain.com` â†’ Backend server IP)
*   Enable Cloudflare features:
    *   SSL/TLS encryption (Full or Full Strict mode)
    *   Auto minify (HTML, CSS, JS)
    *   Brotli compression
    *   HTTP/2 and HTTP/3 support
    *   DDoS protection (automatic)

**Security & Performance:**
*   Set up security headers:
    *   Content Security Policy (CSP)
    *   HSTS (HTTP Strict Transport Security)
    *   X-Frame-Options, X-Content-Type-Options
*   Configure rate limiting (Cloudflare or backend)
*   Set up CDN caching rules
*   Enable WebSocket compression

**Tasks:**

**Delivery Block 1: Cloudflare Pages Setup (Frontend)**
- [ ] **DEPLOY-002:** Create Cloudflare Pages project via dashboard
- [ ] **DEPLOY-003:** Connect GitHub repository to Cloudflare Pages
- [ ] **DEPLOY-004:** Configure build settings (command, output dir, Node version)
- [ ] **DEPLOY-005:** Set environment variables (VITE_API_URL, VITE_WS_URL)
- [ ] **DEPLOY-006:** Test initial deployment with placeholder API URL
- [ ] **DEPLOY-007:** Configure custom domain in Cloudflare Pages
- [ ] **DEPLOY-008:** Verify SSL/TLS certificate provisioned
- [ ] **TEST-013:** Smoke test: Access frontend at custom domain

**Delivery Block 2: Backend Server Setup**
- [ ] **DEPLOY-009:** Provision server/VM (recommend: DigitalOcean, AWS EC2, or Hetzner)
- [ ] **DEPLOY-010:** Install system dependencies (Node 20, CMake, g++, nginx)
- [ ] **DEPLOY-011:** Clone repository and set up deployment directory
- [ ] **DEPLOY-012:** Build C++ native addon on server (`npm run build` in bindings/node)
- [ ] **DEPLOY-013:** Install PM2 process manager (`npm install -g pm2`)
- [ ] **DEPLOY-014:** Create PM2 ecosystem config for API server
- [ ] **DEPLOY-015:** Configure nginx reverse proxy (HTTP/HTTPS/WebSocket)
- [ ] **DEPLOY-016:** Set up Let's Encrypt SSL certificates (certbot)
- [ ] **DEPLOY-017:** Configure firewall rules (ports 80, 443, SSH only)
- [ ] **TEST-014:** Health check: `curl https://api.yourdomain.com/health`

**Delivery Block 3: DNS & Domain Configuration**
- [ ] **DEPLOY-018:** Add DNS A record for frontend (Cloudflare Pages IP)
- [ ] **DEPLOY-019:** Add DNS A record for API server (backend server IP)
- [ ] **DEPLOY-020:** Add DNS A record for WebSocket (same as API or separate)
- [ ] **DEPLOY-021:** Verify DNS propagation (dig/nslookup commands)
- [ ] **DEPLOY-022:** Configure SSL/TLS mode in Cloudflare (Full Strict recommended)
- [ ] **DEPLOY-023:** Enable Cloudflare proxy (orange cloud) for DDoS protection
- [ ] **TEST-015:** Verify HTTPS access for all subdomains

**Delivery Block 4: GitHub Actions CI/CD**
- [ ] **DEPLOY-024:** Create `.github/workflows/deploy-frontend.yml`
    - Trigger on push to main (paths: `apps/web/**`)
    - Build frontend with Vite
    - Deploy to Cloudflare Pages via Wrangler or API
    - Run post-deployment smoke test
- [ ] **DEPLOY-025:** Create `.github/workflows/deploy-backend.yml`
    - Trigger on push to main (paths: `apps/simulation-api/**`, `libs/core/**`)
    - SSH into server (use GitHub secrets for credentials)
    - Pull latest code
    - Rebuild native addon if C++ changed
    - Restart PM2 process with zero downtime
    - Verify health check passes
- [ ] **DEPLOY-026:** Add GitHub secrets for deployment:
    - `CLOUDFLARE_API_TOKEN` or `CLOUDFLARE_ACCOUNT_ID`
    - `SERVER_SSH_KEY`, `SERVER_HOST`, `SERVER_USER`
    - `SERVER_DEPLOY_PATH`
- [ ] **DEPLOY-027:** Test automated deployment end-to-end
- [ ] **TEST-016:** Push test change, verify auto-deployment works

**Delivery Block 5: Monitoring & Logging**
- [ ] **DEPLOY-028:** Set up PM2 log monitoring (`pm2 logs`)
- [ ] **DEPLOY-029:** Configure log rotation (PM2 or logrotate)
- [ ] **DEPLOY-030:** Add uptime monitoring (UptimeRobot or similar)
- [ ] **DEPLOY-031:** Set up error alerting (email/Slack/Discord webhook)
- [ ] **DEPLOY-032:** Configure Cloudflare Analytics for frontend
- [ ] **DEPLOY-033:** Add application performance monitoring (optional: Sentry)

**Delivery Block 6: Performance & Optimization**
- [ ] **DEPLOY-034:** Enable Cloudflare page rules for caching
- [ ] **DEPLOY-035:** Configure browser cache headers in nginx
- [ ] **DEPLOY-036:** Enable gzip/brotli compression in nginx
- [ ] **DEPLOY-037:** Set up CDN caching for static assets
- [ ] **DEPLOY-038:** Test WebSocket performance across regions
- [ ] **TEST-017:** Load test: Verify backend handles 100+ concurrent users

**Delivery Block 7: Documentation**
- [ ] **DOC-005:** Create deployment guide (`docs/DEPLOYMENT.md`)
    - Server setup instructions
    - Environment variables reference
    - Troubleshooting common issues
- [ ] **DOC-006:** Document GitHub Actions workflows
- [ ] **DOC-007:** Create runbook for common operations:
    - Manual deployment steps
    - Rollback procedure
    - Log access and debugging
    - SSL certificate renewal

**Alternative Future Enhancement: WebAssembly Backend**
*For truly serverless Cloudflare Workers deployment (no native addon limitations):*
- [ ] **WASM-001:** Compile C++ erosion engine to WebAssembly (Emscripten)
- [ ] **WASM-002:** Create JavaScript wrapper for WASM module
- [ ] **WASM-003:** Deploy to Cloudflare Workers
- [ ] **WASM-004:** Compare performance: Native vs WASM

**Success Criteria:**
*   Frontend accessible at custom domain with HTTPS.
*   Backend API responds at `api.yourdomain.com/health`.
*   WebSocket connections work from frontend to backend.
*   GitHub push triggers automatic deployment.
*   Zero downtime deployments.
*   SSL certificates auto-renew.
*   Application monitored with alerts.

**Recommended Server Specs (Backend):**
*   **Minimum:** 2 CPU cores, 4GB RAM, 50GB SSD
*   **Recommended:** 4 CPU cores, 8GB RAM, 100GB SSD
*   **OS:** Ubuntu 22.04 LTS or Debian 12
*   **Providers:** DigitalOcean ($24/mo), AWS t3.medium, Hetzner CX32

---

### **Iteration 3: Hydraulic Erosion Simulation**
**Goal:** Implement physics-based hydraulic erosion as the first dynamic simulation method.

**Backend Deliverables:**
*   Implement a particle-based hydraulic erosion algorithm:
    *   Simulate water droplets traversing the terrain.
    *   Sediment pickup, transport, and deposition based on slope and velocity.
    *   Configurable parameters: rain intensity, erosion rate, deposition rate, particle count.
*   Add simulation loop:
    *   Iterate erosion over multiple steps.
    *   Return intermediate heightmaps for animation.
*   Write performance benchmarks (cycles-per-cell, total iteration time).

**Frontend Deliverables:**
*   Add erosion parameter controls:
    *   Sliders for rain intensity, erosion rate, sediment capacity.
    *   Time step and iteration count inputs.
*   Implement playback controls:
    *   Play/Pause/Stop buttons.
    *   Speed multiplier for time-lapse viewing.
*   Real-time terrain updates:
    *   Receive heightmap frames from backend at regular intervals.
    *   Smooth transitions between frames (optional interpolation).

**Integration:**
*   Extend API to support streaming simulation frames (WebSocket or Server-Sent Events).
*   Backend sends `TerrainFrame` objects (heightmap + metadata) to frontend.

**Tasks:**

**Delivery Block 1: Particle Physics + Basic Visualization**
*Water particles move across terrain following gravity. Visible but no erosion yet.*
- [x] **CORE-012:** Implement WaterParticle class (position, velocity, sediment) âœ… Complete with velocity tracking, sediment capacity, and isActive() check
- [x] **CORE-013:** Add gradient calculation for Heightmap (slope, normal vectors) âœ… Complete with bilinear interpolation, central differences, normalized normals
- [x] **CORE-014:** Implement particle movement logic (steepest descent) âœ… Complete with inertia, steepest descent algorithm, velocity updates
- [x] **API-005:** Upgrade to WebSocket server (Socket.io or native WebSockets) âœ… Complete with Socket.io v4.8.3, connection handling, ping/pong
- [x] **API-006:** Create /simulate endpoint (accept basic parameters) âœ… Complete with terrain-frame streaming, batch updates every 1000 particles, placeholder erosion logic
- [x] **WEB-016:** Create ErosionParametersPanel UI component (minimal - Start button) âœ… Complete with 11 parameters, advanced controls, real-time progress bar
- [x] **WEB-020:** Set up WebSocket client connection âœ… Complete with Socket.io-client, connection status logging, error handling
- [x] **WEB-021:** Handle incoming TerrainFrame messages âœ… Complete with frame type handling (initial/update/final), progress tracking
- [x] **WEB-022:** Update terrain mesh with new heightmap data âœ… Complete with real-time heightmap updates, automatic re-rendering
- [x] **TEST-005:** Verify particles follow steepest descent correctly âœ… Complete with comprehensive GoogleTest suite (90/90 tests passing)
**âœ… Deliverable:** Click "Start" â†’ see water particles flowing downhill (READY - needs C++ binding for actual erosion)

**Delivery Block 2: Erosion & Deposition (Full Feature)**
*Complete erosion system - terrain visibly erodes, valleys form.*
- [x] **CORE-015:** Add sediment pickup calculation (erosion rate Ã— slope) âœ… Complete in HydraulicErosion::simulateParticle()
- [x] **CORE-016:** Implement deposition logic (sediment capacity threshold) âœ… Complete with depositSpeed parameter, sediment capacity calculation
- [x] **CORE-017:** Create HydraulicErosion class with configurable parameters âœ… Complete with 11 parameters (inertia, gravity, erodeSpeed, etc.)
- [x] **CORE-020:** Write GoogleTest suite for erosion logic âœ… Complete with 7 erosion-specific tests (all passing)
- [x] **WEB-017:** Add parameter sliders (rain intensity, erosion rate, sediment capacity) âœ… Complete in ErosionParametersPanel with advanced section
- [ ] **WEB-025:** Add error handling for connection failures
- [ ] **TEST-006:** Test parameter edge cases (zero erosion rate, max particles)
**ðŸ”„ Deliverable:** Full working erosion - terrain changes over time (PLACEHOLDER erosion logic - needs C++ binding)

**Delivery Block 3: Advanced Playback Controls**
*Enhanced simulation control - play/pause, speed control, smooth animations.*
- [x] **CORE-018:** Implement simulation loop (multi-step iteration) âœ… Complete with frame-based updates
- [x] **CORE-019:** Add frame snapshot functionality (save intermediate states) âœ… Complete with terrain-frame streaming
- [x] **API-007:** Implement frame streaming (send TerrainFrame objects) âœ… Complete with initial/update/final frames
- [ ] **API-008:** Add simulation control messages (start/stop/pause)
- [x] **WEB-018:** Implement PlaybackControls component (Play/Pause/Stop) âœ… Integrated in ErosionParametersPanel
- [x] **WEB-019:** Add speed multiplier selector (1x, 2x, 5x, 10x) âœ… Complete with 0.5x-5x animation speed slider
- [x] **WEB-023:** Add frame interpolation for smooth transitions âœ… Complete with configurable particles-per-frame
- [x] **WEB-024:** Display simulation progress (iteration count, elapsed time) âœ… Complete with progress bar and particle count
**âœ… Deliverable:** Play/pause simulation, adjust speed, see smooth frame transitions (READY)

**Delivery Block 4: Performance & Documentation**
*Benchmark and optimize for production readiness.*
- [ ] **CORE-021:** Set up Google Benchmark for performance tracking
- [ ] **CORE-022:** Add benchmark tests (cycles-per-cell, throughput)
- [ ] **TEST-007:** Performance test: 256Ã—256 grid at 30+ FPS
- [ ] **DOC-003:** Document hydraulic erosion algorithm and parameters
**âœ… Deliverable:** Performance validated, algorithm documented

**Success Criteria:**
*   User can start/stop erosion simulation with configurable parameters.
*   Terrain visibly evolves over time (valleys form, peaks erode).
*   Simulation runs at acceptable frame rates (target: 30+ FPS for 256Ã—256 grid).

---

### **Iteration 4: Thermal Erosion & Combined Simulation**
**Goal:** Add thermal erosion and enable multi-method simulations.

**Backend Deliverables:**
*   Implement thermal erosion (talus-angle based material slippage).
*   Allow simultaneous execution of hydraulic + thermal erosion.
*   Add material property system:
    *   Per-cell rock hardness coefficient.
    *   Heterogeneous terrain behavior (e.g., soft valleys, hard peaks).

**Frontend Deliverables:**
*   Add thermal erosion controls to UI.
*   Multi-method selector (Hydraulic Only, Thermal Only, Combined).
*   Improved statistics dashboard:
    *   Total sediment moved, average slope, erosion rate graph.

**Tasks:**

**Delivery Block 1: Thermal Erosion Core Algorithm**
- [ ] **CORE-023:** Implement talus angle calculation (angle of repose)
- [ ] **CORE-024:** Add material transfer logic (neighbor height difference)
- [ ] **CORE-025:** Create ThermalErosion class with parameters
- [ ] **CORE-029:** Write unit tests for thermal erosion
- [ ] **TEST-008:** Verify thermal erosion smooths sharp peaks

**Delivery Block 2: Material Properties System**
- [ ] **CORE-027:** Add MaterialProperties layer to Heightmap
- [ ] **CORE-028:** Implement rock hardness coefficient system

**Delivery Block 3: Combined Simulation Orchestrator**
- [ ] **CORE-026:** Implement combined simulation orchestrator
- [ ] **CORE-030:** Add integration tests (hydraulic + thermal combined)
- [ ] **TEST-009:** Test combined simulation produces realistic results
- [ ] **API-009:** Extend /simulate endpoint for combined simulations
- [ ] **API-010:** Add material properties in TerrainFrame payload

**Delivery Block 4: Thermal Erosion UI Controls**
- [ ] **WEB-026:** Create ThermalErosionPanel UI component
- [ ] **WEB-027:** Add simulation method selector (radio buttons/dropdown)
- [ ] **WEB-028:** Implement talus angle slider
- [ ] **WEB-029:** Add material transfer rate control

**Delivery Block 5: Enhanced Statistics Dashboard**
- [ ] **WEB-030:** Expand StatisticsPanel with new metrics
- [ ] **WEB-031:** Add sediment movement graph (real-time chart)
- [ ] **WEB-032:** Display average slope calculation

**Delivery Block 6: Performance & Documentation**
- [ ] **CORE-031:** Benchmark thermal erosion performance
- [ ] **DOC-004:** Document thermal erosion algorithm

**Success Criteria:**
*   Both erosion methods work independently and in combination.
*   User can observe realistic terrain aging (sharp peaks â†’ rounded hills).

---

### **Iteration 5: Performance Optimization & Parallel Execution**
**Goal:** Optimize simulation for high-resolution grids and multi-core CPUs.

**Backend Deliverables:**
*   Add OpenMP parallelization to simulation loops.
*   Implement SIMD-optimized stencil operations for neighbor lookups.
*   Add adaptive LOD (Level of Detail) system for large grids.
*   Integrate Google Benchmark into CI pipeline for regression tracking.

**Frontend Deliverables:**
*   Support for high-resolution terrains (512Ã—512, 1024Ã—1024).
*   Dynamic LOD rendering in R3F (lower detail for distant regions).
*   Performance profiler overlay (FPS, CPU usage, memory consumption).

**Tasks:**

**Delivery Block 1: Multi-threading Parallelization**
- [ ] **CORE-032:** Add OpenMP pragmas to main simulation loops
- [ ] **CORE-033:** Implement grid partitioning for thread distribution
- [ ] **TEST-010:** Verify linear scaling with thread count (1-8 cores)

**Delivery Block 2: SIMD Optimizations**
- [ ] **CORE-034:** Add SIMD intrinsics for height calculations (AVX/SSE)
- [ ] **CORE-035:** Optimize memory access patterns (cache locality)
- [ ] **TEST-012:** Validate SIMD calculations match scalar results

**Delivery Block 3: Memory & Allocation Optimizations**
- [ ] **CORE-041:** Optimize particle allocation (object pools)
- [ ] **CORE-040:** Profile with Valgrind/perf for hotspot identification

**Delivery Block 4: LOD System (Backend)**
- [ ] **CORE-036:** Implement quadtree LOD structure
- [ ] **CORE-037:** Add distance-based resolution switching

**Delivery Block 5: High-Resolution Support (Frontend)**
- [ ] **WEB-033:** Add resolution selector (256, 512, 1024)
- [ ] **WEB-034:** Implement R3F LOD components
- [ ] **WEB-035:** Add distance culling for far terrain chunks
- [ ] **TEST-011:** Test 1024Ã—1024 grid at 15+ FPS

**Delivery Block 6: Performance Monitoring UI**
- [ ] **WEB-036:** Create PerformanceProfiler overlay component
- [ ] **WEB-037:** Display FPS counter (real-time)
- [ ] **WEB-038:** Add CPU/GPU usage metrics (if available)
- [ ] **WEB-039:** Show memory consumption tracker
- [ ] **WEB-040:** Implement performance graph (historical data)

**Delivery Block 7: CI Integration & Documentation**
- [ ] **CORE-038:** Write scalability benchmarks (1-16 threads)
- [ ] **CORE-039:** Add benchmark regression checks to CI
- [ ] **DOC-005:** Document performance tuning guidelines

**Success Criteria:**
*   Simulation achieves near-linear scaling with thread count.
*   1024Ã—1024 grid runs at interactive frame rates (15+ FPS).
*   No performance regressions detected in CI benchmarks.

---

### **Iteration 6: Preset Library & Export Features**
**Goal:** Add user convenience features for saving, loading, and sharing terrains.

**Backend Deliverables:**
*   Implement heightmap serialization (save/load from disk).
*   Add preset configuration system (JSON-based parameter templates).

**Frontend Deliverables:**
*   Preset library UI:
    *   Thumbnails of pre-configured terrains (Canyon, Mountain, Coastal).
    *   One-click load functionality.
*   Export features:
    *   Download heightmap as PNG/EXR.
    *   Export simulation parameters as JSON.
    *   Share link generation (URL-encoded parameters).

**Tasks:**

**Delivery Block 1: Heightmap Serialization Core**
- [ ] **CORE-042:** Implement Heightmap serialization to binary format
- [ ] **CORE-047:** Write unit tests for serialization

**Delivery Block 2: Export Formats (PNG/EXR)**
- [ ] **CORE-043:** Add PNG export (heightmap as grayscale image)
- [ ] **CORE-044:** Implement EXR export (HDR elevation data)
- [ ] **API-011:** Create /export endpoint (supports PNG/EXR/JSON)
- [ ] **TEST-013:** Verify exported heightmaps load correctly in Blender

**Delivery Block 3: Preset System Backend**
- [ ] **CORE-045:** Create JSON schema for preset configurations
- [ ] **CORE-046:** Add preset loader/validator
- [ ] **API-012:** Add /presets endpoint (list available presets)
- [ ] **API-013:** Implement /load-preset endpoint
- [ ] **TEST-014:** Test JSON parameter round-trip (save â†’ load)

**Delivery Block 4: Preset Library UI**
- [ ] **WEB-041:** Create PresetLibrary UI component
- [ ] **WEB-042:** Design preset cards with thumbnails
- [ ] **WEB-043:** Add preset search/filter functionality
- [ ] **WEB-044:** Implement one-click load button
- [ ] **WEB-050:** Add preset saving dialog (user-created presets)

**Delivery Block 5: Export Panel UI**
- [ ] **WEB-045:** Create ExportPanel UI component
- [ ] **WEB-046:** Add format selector (PNG/EXR/JSON)
- [ ] **WEB-047:** Implement download functionality

**Delivery Block 6: Share & Collaboration Features**
- [ ] **WEB-048:** Add share link generator (URL encoding)
- [ ] **WEB-049:** Implement clipboard copy for share links
- [ ] **TEST-015:** Validate share links restore exact simulation state

**Delivery Block 7: Documentation**
- [ ] **DOC-006:** Document export formats and preset structure

**Success Criteria:**
*   User can save and restore simulation sessions.
*   Presets provide quick-start templates for experimentation.
*   Exported heightmaps are compatible with external 3D tools (Blender, Unity).
    *   Heterogeneous terrain behavior (e.g., soft valleys, hard peaks).

**Frontend Deliverables:**
*   Add thermal erosion controls to UI.
*   Multi-method selector (Hydraulic Only, Thermal Only, Combined).
*   Improved statistics dashboard:
    *   Total sediment moved, average slope, erosion rate graph.

**Success Criteria:**
*   Both erosion methods work independently and in combination.
*   User can observe realistic terrain aging (sharp peaks â†’ rounded hills).

---

### **Iteration 5: Performance Optimization & Parallel Execution**
**Goal:** Optimize simulation for high-resolution grids and multi-core CPUs.

**Backend Deliverables:**
*   Add OpenMP parallelization to simulation loops.
*   Implement SIMD-optimized stencil operations for neighbor lookups.
*   Add adaptive LOD (Level of Detail) system for large grids.
*   Integrate Google Benchmark into CI pipeline for regression tracking.

**Frontend Deliverables:**
*   Support for high-resolution terrains (512Ã—512, 1024Ã—1024).
*   Dynamic LOD rendering in R3F (lower detail for distant regions).
*   Performance profiler overlay (FPS, CPU usage, memory consumption).

**Success Criteria:**
*   Simulation achieves near-linear scaling with thread count.
*   1024Ã—1024 grid runs at interactive frame rates (15+ FPS).
*   No performance regressions detected in CI benchmarks.

---

### **Iteration 6: Preset Library & Export Features**
**Goal:** Add user convenience features for saving, loading, and sharing terrains.

**Backend Deliverables:**
*   Implement heightmap serialization (save/load from disk).
*   Add preset configuration system (JSON-based parameter templates).

**Frontend Deliverables:**
*   Preset library UI:
    *   Thumbnails of pre-configured terrains (Canyon, Mountain, Coastal).
    *   One-click load functionality.
*   Export features:
    *   Download heightmap as PNG/EXR.
    *   Export simulation parameters as JSON.
    *   Share link generation (URL-encoded parameters).

**Success Criteria:**
*   User can save and restore simulation sessions.
*   Presets provide quick-start templates for experimentation.
*   Exported heightmaps are compatible with external 3D tools (Blender, Unity).

---

### **Future Iterations (Roadmap Extensions)**

*   **Iteration 7:** Tectonic deformation (uplift, folding, fault lines).
*   **Iteration 8:** Interactive sculpting tools (raise/lower, smooth, flatten brushes).
*   **Iteration 9:** Real-world data import (GeoTIFF, DEM files).
*   **Iteration 10:** Advanced rendering (PBR materials, atmospheric effects, shadows).
*   **Iteration 11:** Multiplayer/collaborative editing (real-time shared simulations).
*   **Iteration 12:** Machine learning integration (erosion pattern prediction, terrain generation from text prompts).

---

**Iteration Principles:**
*   Each iteration is fully tested and deployable.
*   CI/CD pipeline validates all changes before merging.
*   User feedback informs priority adjustments between iterations.
*   Technical debt is addressed incrementally (no "big bang" refactors).