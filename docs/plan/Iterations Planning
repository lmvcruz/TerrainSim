Implementation Roadmap (Iterative Development)

The project follows an iterative development model, with each iteration delivering a functional, testable increment that builds upon the previous iteration. This approach ensures continuous integration, early feedback, and incremental complexity growth.

---

### **Iteration 1: Foundation & Basic Visualization**
**Goal:** Establish the core infrastructure and render a simple, static heightmap.

**Backend Deliverables:**
*   Set up Monorepo structure with pnpm workspaces.
*   Configure CI/CD pipeline (GitHub Actions) with basic linting and test runners.
*   Implement a simple `Heightmap` class in C++ (`libs/core`):
    *   Fixed-size 2D grid (e.g., 256×256).
    *   Generic data container with no initialization strategies built-in.
    *   Basic getters/setters for grid access.
*   Create `TerrainGenerators` module with factory functions:
    *   `generateSemiSphere()` - Hemisphere shape for testing
    *   `generateCone()` - Conical peak
    *   `generateSigmoid()` - Smooth transition surface
    *   These functions create and return configured Heightmap instances
*   Write initial GoogleTest suite for `Heightmap` class (boundary checks, memory layout).

**Design Note:** The Heightmap class is intentionally kept generic and free of initialization logic. Terrain generation strategies (semi-sphere, cone, noise, etc.) are implemented as separate factory functions in the TerrainGenerators module. This separation maintains single responsibility and allows easy extension of generation methods without modifying the core Heightmap class.

**Frontend Deliverables:**
*   Set up React + Vite + TypeScript project (`apps/web`).
*   Implement basic R3F terrain component:
    *   Plane geometry with vertex displacement shader.
    *   Load heightmap data from a static Float32Array.
    *   Simple grayscale or single-color material.
*   Add orbit controls for camera navigation.
*   Display a flat or manually defined heightmap (e.g., a pyramid or ramp).

**Integration:**
*   No API yet; frontend uses hardcoded heightmap data for testing.

**Tasks:**
- [x] **INFRA-001:** Initialize pnpm-workspace.yaml and root package.json
- [x] **INFRA-002:** Set up GitHub Actions workflow (build + test jobs)
- [x] **INFRA-003:** Configure linting tools (ESLint for TS, clang-format for C++)
- [x] **CORE-001:** Create Heightmap class with 2D grid storage (Row-Major Order)
- [x] **CORE-002:** Create TerrainGenerators module with factory functions (semi-sphere, cone, sigmoid)
- [x] **CORE-003:** Add getter/setter methods (at(), set(), width(), height())
- [x] **CORE-004:** Write GoogleTest suite (10+ test cases)
- [x] **CORE-005:** Add CMakeLists.txt with GoogleTest integration
- [x] **WEB-001:** Scaffold React + Vite + TypeScript app (apps/web)
- [x] **WEB-002:** Install Three.js and React Three Fiber dependencies
- [x] **WEB-003:** Create TerrainMesh component with PlaneGeometry
- [x] **WEB-004:** Implement vertex displacement shader (basic GLSL)
- [x] **WEB-005:** Add OrbitControls for camera navigation
- [x] **WEB-006:** Load hardcoded Float32Array heightmap data
- [x] **TEST-001:** Verify CI pipeline passes all checks
- [x] **TEST-002:** Manual test: Render semi-sphere in 3D viewport
- [x] **DEPLOY-001:** Configure GitHub Pages deployment with GitHub Actions
- [x] **DOC-001:** Update README with build and run instructions

**Success Criteria:**
*   CI pipeline runs successfully (build + tests pass).
*   3D viewport renders a simple terrain mesh.
*   User can rotate, pan, and zoom the camera.

---

### **Iteration 1.5: Testing & Debugging Infrastructure**
**Goal:** Establish comprehensive testing, logging, and debugging capabilities to support rapid development and AI-assisted debugging.

**Backend Deliverables:**
*   Set up development log endpoints (`/dev/logs`):
    *   POST endpoint to receive browser logs from frontend.
    *   GET endpoint with filtering (level, component, timestamp, limit).
    *   DELETE endpoint to clear logs.
    *   File-based storage in `.dev-logs/browser-logs.json` (max 5000 entries).
*   Configure backend for CORS with DELETE method support.

**Frontend Deliverables:**
*   Achieve >85% test coverage for critical components:
    *   Install `@vitest/coverage-v8` for code coverage reporting.
    *   Write comprehensive tests for `App.tsx` state management.
    *   Add 14 tests for `TerrainMesh.tsx` component (texture updates, prop changes, lifecycle).
    *   Mock Three.js objects for JSDOM environment.
*   Implement centralized logging system:
    *   Create `Logger` class with log levels (debug, info, warn, error).
    *   Add component-scoped loggers (e.g., `TerrainMesh`, `App`).
    *   Implement log groups for related operations.
    *   Add performance timing utilities (`logger.time()`, `logger.timeAsync()`, `logger.measure()`).
    *   Replace all `console.log` calls with structured logging.
*   Create `LogCollector` for development:
    *   Capture all logs in memory with filtering capabilities.
    *   Auto-save to localStorage every 5 seconds.
    *   Provide `window.downloadLogs()` for manual export.
    *   Auto-send logs to backend every 30 seconds (if available).
    *   Graceful degradation when backend unavailable.
*   Set up Playwright for E2E and visual regression testing:
    *   Install Playwright with Chromium browser.
    *   Create functional E2E tests (app load, API connection, console errors).
    *   Implement visual regression test with baseline screenshots.
    *   Configure generous diff tolerances for WebGL rendering (maxDiffPixels: 1000).
    *   Add test scripts: `test:e2e`, `test:visual`, `test:e2e:ui`, `test:visual:update`.

**Integration:**
*   Backend and frontend coordinate for log collection:
    *   Frontend checks backend health on startup.
    *   If available, enables automatic log transmission.
    *   Backend stores logs with query/filter capabilities.
    *   AI agents can retrieve logs via HTTP GET without manual user intervention.
*   CI pipeline extended with E2E tests:
    *   Step 2 in CI script runs E2E and visual tests.
    *   Auto-starts both API server and web server for tests.
    *   Visual baselines stored in version control.

**Tasks:**
- [x] **TEST-101:** Install @vitest/coverage-v8 package
- [x] **TEST-102:** Generate initial coverage report (58.15% baseline)
- [x] **TEST-103:** Write App.tsx state management tests
- [x] **TEST-104:** Create TerrainMesh.tsx comprehensive test suite (14 tests)
- [x] **TEST-105:** Implement Three.js mocking for JSDOM
- [x] **TEST-106:** Achieve 86.95% overall coverage
- [x] **LOG-001:** Create Logger class with log levels
- [x] **LOG-002:** Add component-scoped logger factory
- [x] **LOG-003:** Implement log groups for operation tracking
- [x] **LOG-004:** Add performance timing utilities
- [x] **LOG-005:** Replace all console.log with structured logging
- [x] **LOG-006:** Create LogCollector class
- [x] **LOG-007:** Implement localStorage auto-save (5s interval)
- [x] **LOG-008:** Add downloadLogs() helper function
- [x] **LOG-009:** Expose window.downloadLogs() for debugging
- [x] **API-014:** Create POST /dev/logs endpoint
- [x] **API-015:** Create GET /dev/logs endpoint with filtering
- [x] **API-016:** Create DELETE /dev/logs endpoint
- [x] **API-017:** Implement file-based log storage (max 5000 entries)
- [x] **API-018:** Add CORS support for DELETE method
- [x] **WEB-051:** Implement backend health check on startup
- [x] **WEB-052:** Enable auto-send logs every 30 seconds
- [x] **WEB-053:** Implement graceful degradation for offline mode
- [x] **E2E-001:** Install Playwright and Chromium browser
- [x] **E2E-002:** Create playwright.config.ts with auto-server startup
- [x] **E2E-003:** Write functional E2E tests (terrain.spec.ts)
- [x] **E2E-004:** Create visual regression proof-of-concept (visual-poc.spec.ts)
- [x] **E2E-005:** Generate baseline screenshots
- [x] **E2E-006:** Configure diff tolerances for WebGL rendering
- [x] **E2E-007:** Add Playwright test scripts to package.json
- [x] **E2E-008:** Integrate E2E tests into CI pipeline (Step 2)
- [x] **E2E-009:** Update .gitignore for Playwright artifacts
- [x] **DOC-007:** Create LOGGING_SYSTEM.md documentation
- [x] **DOC-008:** Create AGENT_DEBUGGING_WORKFLOW.md
- [x] **DOC-009:** Create VISUAL_REGRESSION_TESTING.md
- [x] **DOC-010:** Update TESTING_AND_DEBUGGING_IMPROVEMENTS.md roadmap

**Success Criteria:**
*   Test coverage exceeds 85% for critical frontend components.
*   All console output uses structured logging with appropriate levels.
*   AI agents can retrieve browser logs programmatically via HTTP API.
*   E2E tests run successfully in CI pipeline.
*   Visual regression tests detect unintended UI changes.
*   CI pipeline includes 5 steps: (1) Frontend Tests, (2) E2E & Visual, (3) Backend Tests, (4) Build, (5) Deploy Check.

---

### **Iteration 2: Procedural Noise Generation**
**Goal:** Add parameterized noise functions for terrain generation.

**Backend Deliverables:**
*   Implement Perlin Noise algorithm in `libs/core`:
    *   Configurable parameters: seed, frequency, amplitude.
    *   Pure function: `generatePerlinNoise(width, height, seed, frequency, amplitude) -> Heightmap`.
*   Add unit tests for noise generation (deterministic output, value ranges).
*   Implement Fractional Brownian Motion (fBm):
    *   Layered octaves of Perlin noise.
    *   Parameters: octave count, persistence, lacunarity.

**Frontend Deliverables:**
*   Add UI controls for noise generation:
    *   Seed input field.
    *   Sliders for frequency, amplitude, octaves.
    *   "Generate" button to trigger terrain creation.
*   Improve visualization:
    *   Color gradient based on elevation (low = blue, mid = green, high = white).
    *   Wireframe toggle for debugging.
*   Add basic statistics display (min/max elevation).

**Integration:**
*   Create a simple local API endpoint (e.g., HTTP server or direct WASM binding) to call C++ noise functions from the frontend.
*   Frontend sends parameters and receives heightmap as Float32Array.

**Tasks:**
- [x] **CORE-006:** Implement Perlin Noise gradient generation
- [x] **CORE-007:** Add interpolation functions (smoothstep, lerp)
- [x] **CORE-008:** Create generatePerlinNoise() function
- [x] **CORE-009:** Write unit tests for noise determinism
- [x] **CORE-010:** Implement fBm with octave layering
- [x] **CORE-011:** Add parameter validation (range checks)
- [x] **API-001:** Set up simple HTTP server (Express.js or Crow C++)
- [x] **API-002:** Create /generate endpoint accepting noise parameters
- [x] **API-003:** Serialize Heightmap to Float32Array in response
- [x] **API-004:** Add CORS support for local development
- [x] **WEB-007:** Enhance material with elevation-based color gradient
- [x] **WEB-008:** Create NoiseParametersPanel UI component
- [x] **WEB-009:** Add seed input field with validation
- [x] **WEB-010:** Implement sliders (frequency, amplitude, octaves)
- [x] **WEB-011:** Wire "Generate" button to API call
- [x] **WEB-012:** Implement elevation-based color gradient shader
- [x] **WEB-013:** Add wireframe toggle button
- [x] **WEB-014:** Create StatisticsPanel component (min/max elevation)
- [x] **WEB-015:** Handle loading states and error messages
- [x] **TEST-003:** Verify same seed produces identical terrain
- [x] **TEST-004:** Test different parameter combinations
- [x] **DOC-002:** Document API endpoints and parameters

**Success Criteria:**
*   User can generate varied terrains by adjusting noise parameters.
*   Different seeds produce reproducible but distinct terrains.
*   Color-coded elevation provides visual feedback.

---

### **Iteration 2.5: Production Deployment**
**Goal:** Deploy application to production with CI/CD.

**Architecture:**
*   **Frontend:** Cloudflare Pages (https://terrainsim.lmvcruz.work)
*   **Backend:** AWS EC2 t3.micro (https://api.lmvcruz.work)
*   **CI/CD:** GitHub Actions (.github/workflows/ci.yml)

**Environment Variables:**
*   `VITE_API_URL=https://api.lmvcruz.work`
*   `VITE_WS_URL=wss://api.lmvcruz.work`

**Server Details:**
*   **IP:** 54.242.131.12
*   **OS:** Ubuntu 22.04 LTS
*   **Specs:** 1 vCPU, 1GB RAM, 30GB SSD
*   **Path:** /var/www/terrainsim
*   **Process Manager:** PM2 v6.0.14
*   **Node:** v20.19.6

**Tasks:**
- [x] **DEPLOY-002:** Cloudflare Pages project setup
- [x] **DEPLOY-003:** GitHub repository connected
- [x] **DEPLOY-004:** Build configured: `pnpm --filter @terrain/web run build` → `apps/web/dist`
- [x] **DEPLOY-005:** Environment variables configured
- [x] **DEPLOY-007:** Custom domain: terrainsim.lmvcruz.work
- [x] **DEPLOY-009:** AWS EC2 t3.micro provisioned (54.242.131.12)
- [x] **DEPLOY-010:** Dependencies installed (Node v20.19.6, CMake, g++, nginx)
- [x] **DEPLOY-011:** Repository cloned to /var/www/terrainsim
- [x] **DEPLOY-012:** Native addon built (terrain_erosion_native.node)
- [x] **DEPLOY-013:** PM2 v6.0.14 configured
- [x] **DEPLOY-014:** PM2 ecosystem config created
- [x] **DEPLOY-015:** nginx reverse proxy configured
- [x] **DEPLOY-016:** Let's Encrypt SSL certificates
- [x] **DEPLOY-017:** Firewall rules configured (22, 80, 443)
- [x] **DEPLOY-018:** DNS A record: terrainsim.lmvcruz.work
- [x] **DEPLOY-019:** DNS A record: api.lmvcruz.work → 54.242.131.12
- [x] **DEPLOY-020:** DNS A record for WebSocket
- [x] **DEPLOY-021:** DNS propagation verified
- [x] **DEPLOY-022:** Cloudflare SSL/TLS Full mode
- [x] **DEPLOY-023:** Cloudflare proxy enabled
- [x] **DEPLOY-026:** GitHub secrets configured
- [x] **DEPLOY-034:** Cloudflare CDN caching enabled
- [x] **DEPLOY-036:** nginx gzip compression enabled
- [x] **DOC-005:** docs/DEPLOYMENT.md created
- [x] **DOC-006:** GitHub Actions workflows documented
- [x] **DOC-007:** Runbook created

**Success Criteria:**
*   Frontend: https://terrainsim.lmvcruz.work ✅
*   API: https://api.lmvcruz.work/health ✅
*   WebSocket: wss://api.lmvcruz.work ✅
*   Frontend auto-deploys on push ✅
*   SSL auto-renews ✅

---

### **Iteration 3: Hydraulic Erosion Simulation**
**Goal:** Real-time physics-based erosion simulation.

**Production:**
*   **URL:** https://terrainsim.lmvcruz.work
*   **Backend:** C++ erosion engine + Node-API binding (122KB)
*   **Tests:** 90/90 passing

**Tasks:**
- [x] **CORE-012:** WaterParticle class (position, velocity, sediment)
- [x] **CORE-013:** Gradient calculation (slope, normal vectors)
- [x] **CORE-014:** Particle movement (steepest descent, inertia)
- [x] **CORE-015:** Sediment pickup calculation
- [x] **CORE-016:** Deposition logic (capacity threshold)
- [x] **CORE-017:** HydraulicErosion class (11 parameters)
- [x] **CORE-018:** Simulation loop (multi-step iteration)
- [x] **CORE-019:** Frame snapshot functionality
- [x] **CORE-020:** Erosion-specific tests (7 tests)
- [x] **API-005:** WebSocket server (Socket.io v4.8.3)
- [x] **API-006:** /simulate endpoint with terrain-frame streaming
- [x] **API-007:** Frame streaming (initial/update/final frames)
- [x] **WEB-016:** ErosionParametersPanel (11 parameters)
- [x] **WEB-017:** Parameter sliders (erosion rate, sediment capacity)
- [x] **WEB-018:** PlaybackControls (Play/Pause/Stop)
- [x] **WEB-019:** Speed multiplier (0.5x-5x)
- [x] **WEB-020:** WebSocket client connection
- [x] **WEB-021:** TerrainFrame message handling
- [x] **WEB-022:** Real-time heightmap updates
- [x] **WEB-023:** Frame interpolation
- [x] **WEB-024:** Progress tracking (progress bar, particle count)
- [x] **TEST-005:** GoogleTest suite (90/90 tests passing)

**Success Criteria:**
*   Start/stop erosion with parameters ✅
*   Terrain evolves over time (valleys form, peaks erode) ✅
*   30+ FPS for 256×256 grid ✅

---

### **Iteration 3.5: Infrastructure & Erosion Polish**
**Goal:** Complete deferred tasks from Iterations 2.5 and 3.

**Server Details:**
*   **IP:** 54.242.131.12
*   **Path:** /var/www/terrainsim
*   **PM2:** `ssh terrainsim "pm2 logs terrainsim-api"`

**Tasks:**

**Delivery Block 1: Erosion Polish** (High Priority)
- [x] **WEB-025:** WebSocket connection error handling (connection failures, disconnections, automatic reconnection)
- [x] **WEB-025a:** Remove pause button from UI (rethinking simulation controls for future iteration)
- [x] **TEST-006:** Parameter edge case testing (zero values, negative parameters, boundary conditions)
- [x] **DOC-003:** Hydraulic erosion algorithm documentation

**Delivery Block 2: Monitoring & Observability**
- [x] **DEPLOY-028:** PM2 log monitoring with structured output (human-readable with timestamps)
- [x] **DEPLOY-029:** Log rotation (90 days retention, 100MB max, gzip compression)
- [x] **DEPLOY-030:** Uptime monitoring (UptimeRobot → /health, /generate, WebSocket, frontend + response times + multiple regions)
- [x] **DEPLOY-031:** Error alerting (Email to lmvcruz@gmail.com via UptimeRobot with flood prevention)
- [x] **DEPLOY-032:** Cloudflare Analytics (automatically enabled, documentation provided)
- [~] **DEPLOY-033:** APM (Sentry) - SKIPPED (focusing on free tools: PM2, UptimeRobot, Cloudflare)

**Delivery Block 3: Backend CI/CD Automation**
- [x] **DEPLOY-024:** Setup GitHub Actions SSH authentication (webfactory/ssh-agent + SSH_PRIVATE_KEY secret)
- [x] **DEPLOY-025:** Create manual-trigger backend deployment workflow (workflow_dispatch with rebuild parameter: none/incremental/full)
- [x] **DEPLOY-027:** Post-deployment health checks (30 retries, 60 seconds timeout, alert on failure)

**Delivery Block 4: Performance Optimization**
- [x] **TEST-017:** Load testing with k6 (10 concurrent users, all scenarios: /health baseline, /generate terrain generation, WebSocket /simulate erosion streaming)
- [x] **CORE-021:** Google Benchmark setup (CMakeLists.txt integration, manual trigger only - not in CI pipeline)
- [x] **CORE-022:** Benchmark tests for all C++ operations (hydraulic erosion particle simulation, Perlin noise generation, fBm layering, heightmap operations)
- [x] **TEST-007:** Performance baseline documentation (create docs/infra/PERFORMANCE_METRICS.md with current FPS, latency, throughput, bottleneck analysis, end-to-end pipeline metrics)

**Delivery Block 5: Documentation Reorganization**
- [x] **DOC-100:** Scan and inventory all files in docs/ folder
- [x] **DOC-101:** Create new documentation structure:
  - `docs/plan/` - Main plan and specifications (Iterations Planning, System Spec)
  - `docs/temp/` - Temporary documents (delete after use)
  - `docs/infra/` - Infrastructure documentation (deployment, CI/CD, monitoring)
  - `docs/algorithms/` - Algorithm documentation (erosion, noise generation, etc.)
  - `docs/doc/` - How-to guides and API documentation
- [x] **DOC-102:** Move existing documentation to appropriate folders
- [x] **DOC-103:** Delete temporary/outdated documentation files (removed 10 files)
- [x] **DOC-104:** Update README.md with new documentation structure (added documentation section with links to docs/README.md and category folders)
- [x] **DOC-105:** Create index files for each documentation category (docs/README.md created)

**Success Criteria:**
*   Connection errors handled gracefully ✅
*   WebSocket auto-reconnection working ✅
*   Edge cases tested ✅
*   Documentation organized and accessible ✅
*   Uptime monitoring alerts within 5 minutes ✅
*   Backend deploys via GitHub Actions with manual trigger ✅
*   Health checks validate deployment success ✅
*   Load testing completed with k6 ✅
*   Performance benchmarks established ✅
*   Performance baseline documented ✅
*   Documentation reorganized into logical structure ✅


---

### **Iteration 3.6: Job-Based Pipeline System**
**Goal:** Implement job-based simulation pipeline with full coverage validation and integrated UI.

**Tasks:**

**Delivery Block 1: Backend Foundation (Data Model & Validation)**
- [x] **CORE-012:** Implement SimulationJob and SimulationStep data structures
- [x] **CORE-013:** Create JobValidator class with coverage checking
  - Validate full frame coverage (no gaps allowed)
  - Detect overlapping jobs
  - Return structured validation results (errors, warnings)
- [x] **CORE-014:** Implement JobExecutor class
  - Frame-by-frame execution loop
  - Apply jobs sequentially to frame ranges
  - Handle multiple jobs per step (last wins)
- [x] **CORE-015:** Create JSON configuration parser
  - Parse Step 0 (modeling configuration)
  - Parse steps and jobs arrays
  - Schema validation (required fields, valid ranges)
- [x] **TEST-201:** Write JobValidator unit tests (12 cases: gaps, overlaps, edge cases)
- [x] **TEST-202:** Write JobExecutor unit tests (9 cases: single/multiple jobs, ordering)
- [x] **TEST-203:** Write Config Parser unit tests (15 cases: valid/invalid JSON)

**Delivery Block 2: API Layer**
- [x] **API-007:** Create POST /config/validate endpoint
  - Input: Pipeline configuration JSON
  - Output: Validation result (isValid, uncoveredFrames, warnings)
- [x] **API-008:** Create POST /config/save endpoint (save config to file)
- [x] **API-009:** Create GET /config/load/:id endpoint (load saved config)
- [x] **API-010:** Implement session-based POST /simulate endpoints
  - POST /simulate/create: Initialize session with config
  - POST /simulate/execute: Execute single frame by sessionId and frame number
  - DELETE /simulate/session/:id: Clean up session and free memory
  - Session management with automatic cleanup (30-minute timeout)
- [x] **API-011:** Implement WebSocket progress events
  - Emit frame:complete when each frame finishes
  - Event payload: { sessionId, frame, heights, width, height }
  - WebSocket event: job-simulation:start for frame-by-frame streaming
- [x] **TEST-204:** Write API integration tests (end-to-end: create → validate → execute)

**Delivery Block 3: Frontend Foundation (UI Layout & Panels)**
- [x] **WEB-054:** Create integrated 4-panel layout
  - Left: Pipeline Builder (collapsible)
  - Center: 3D Viewer with playback scrubber
  - Right: Job Manager (collapsible)
  - Bottom: Configuration Timeline
  - Implement panel resize/collapse functionality
- [x] **WEB-055:** Create Pipeline Builder panel
  - Display available steps (Hydraulic, Thermal)
  - Toggle steps enabled/disabled
  - Configure Step 0 (noise method, parameters)
- [x] **WEB-056:** Create Job Manager panel
  - List all jobs with key info (name, step, frame range)
  - Create job button → opens modal
  - Edit/delete job actions
  - Enable/disable jobs
  - Visual indicators for job status
- [x] **WEB-057:** Create Configuration Timeline component
  - Horizontal timeline from frame 0 to totalFrames
  - Render color-coded bars for job assignments
  - Green fill: Covered frames
  - Red fill: Uncovered frames (error state)
  - Yellow outline: Overlapping jobs
  - Display current frame indicator
  - Click to jump to frame
  - Hover tooltips showing job details

**Delivery Block 4: Job Creation & Configuration**
- [x] **WEB-058:** Create Create/Edit Job modal
  - Job name input
  - Step selection dropdown
  - Frame range inputs (start, end)
  - Step-specific configuration form
  - Real-time validation feedback
  - Preview how job affects coverage
- [x] **INT-005:** Implement job templates system
  - Create 1-2 preset templates per step type:
    - Hydraulic: "Heavy Erosion", "Light Smoothing"
    - Thermal: "Aggressive Collapse", "Gentle Settling"
  - "Create from Template" option in UI
  - Template parameter preview

**Delivery Block 5: Validation & Error Handling**

**IMPORTANT CLARIFICATIONS:**
- **Job Execution Model:** Jobs execute SEQUENTIALLY in creation order (NOT "last wins")
  - First job: Uses previous frame as input
  - Subsequent jobs: Use result of previous job as input
  - Last job: Result returned to frontend
  - This applies to overlapping frames - all overlapping jobs execute in sequence

**Tasks:**
- [ ] **INT-006:** Implement Simulate/Play/Reset button architecture
  - Timeline (bottom panel) buttons:
    - "Simulate" button: Creates frames, fills cache, disabled when validation fails
    - "Reset" button: Cleans up cache (deletes models, preserves configuration)
  - Viewer (center panel) buttons:
    - "Play" button: Plays animation from cached frames
    - "Back"/"Forward" buttons: Frame-by-frame navigation
  - Button state management:
    - Simulate disabled when validation.isValid === false
    - Simulate changes to "Stop" during execution
    - Stop finishes server session, keeps cache intact
- [ ] **INT-007:** Enhanced timeline visual feedback
  - Display frame numbers along timeline
  - Show active jobs with color-coded bars
  - Red segments for coverage gaps (visual indicator for invalid state)
  - Current frame indicator
  - Click to jump to frame
- [ ] **TEST-205:** Write frontend E2E tests
  - Test: Build pipeline → Create jobs → Simulate → Play → View results
  - Test: Simulate → Stop → Verify cache preserved
  - Test: Reset → Verify cache cleared
  - Test: Frame-by-frame navigation with Back/Forward buttons

**Delivery Block 6: Configuration Persistence**
- [ ] **INT-008:** Implement configuration save/load
  - Save button → download .terrainconfig.json
  - Load button → file picker → parse and populate UI
  - Auto-save to browser localStorage (draft recovery)
  - Recent configurations menu
- [ ] **TEST-206:** Write save/load round-trip tests

**Delivery Block 7: Documentation**
- [ ] **DOC-014:** Document all new API endpoints (validate, save, load)
- [ ] **DOC-015:** Create user guide for job system
  - How to create jobs
  - Understanding coverage validation
  - Using templates
  - Save/load workflows
- [ ] **DOC-016:** Write developer architecture notes
  - Job execution model
  - Validation algorithms
  - UI state management

**Success Criteria:**
- User can create 3-job simulation in < 2 minutes
- Validation feedback appears in < 500ms
- Timeline renders 200 frames smoothly (60fps)
- Configuration save/load works 100% reliably
- All backend classes have >80% test coverage
- Zero crashes with valid configurations

---

### **Iteration 4: Thermal Erosion & Combined Simulation**
**Goal:** Add thermal erosion and enable multi-method simulations.

**Backend Deliverables:**
*   Implement thermal erosion (talus-angle based material slippage).
*   Allow simultaneous execution of hydraulic + thermal erosion.
*   Add material property system:
    *   Per-cell rock hardness coefficient.
    *   Heterogeneous terrain behavior (e.g., soft valleys, hard peaks).

**Frontend Deliverables:**
*   Add thermal erosion controls to UI.
*   Multi-method selector (Hydraulic Only, Thermal Only, Combined).
*   Improved statistics dashboard:
    *   Total sediment moved, average slope, erosion rate graph.

**Tasks:**

**Delivery Block 1: Thermal Erosion Core Algorithm**
- [ ] **CORE-023:** Implement talus angle calculation (angle of repose)
- [ ] **CORE-024:** Add material transfer logic (neighbor height difference)
- [ ] **CORE-025:** Create ThermalErosion class with parameters
- [ ] **CORE-029:** Write unit tests for thermal erosion
- [ ] **TEST-008:** Verify thermal erosion smooths sharp peaks

**Delivery Block 2: Material Properties System**
- [ ] **CORE-027:** Add MaterialProperties layer to Heightmap
- [ ] **CORE-028:** Implement rock hardness coefficient system

**Delivery Block 3: Combined Simulation Orchestrator**
- [ ] **CORE-026:** Implement combined simulation orchestrator
- [ ] **CORE-030:** Add integration tests (hydraulic + thermal combined)
- [ ] **TEST-009:** Test combined simulation produces realistic results
- [ ] **API-009:** Extend /simulate endpoint for combined simulations
- [ ] **API-010:** Add material properties in TerrainFrame payload

**Delivery Block 4: Thermal Erosion UI Controls**
- [ ] **WEB-026:** Create ThermalErosionPanel UI component
- [ ] **WEB-027:** Add simulation method selector (radio buttons/dropdown)
- [ ] **WEB-028:** Implement talus angle slider
- [ ] **WEB-029:** Add material transfer rate control

**Delivery Block 5: Enhanced Statistics Dashboard**
- [ ] **WEB-030:** Expand StatisticsPanel with new metrics
- [ ] **WEB-031:** Add sediment movement graph (real-time chart)
- [ ] **WEB-032:** Display average slope calculation

**Delivery Block 6: Performance & Documentation**
- [ ] **CORE-031:** Benchmark thermal erosion performance
- [ ] **DOC-004:** Document thermal erosion algorithm

**Delivery Block 7: Deployment Resilience Discussion**
- [ ] **DEPLOY-039:** Evaluate deployment failure strategies (rollback, retry, alert-only)
- [ ] **DEPLOY-040:** Document recommended approach for production resilience
- [ ] **DEPLOY-041:** Implement chosen strategy in backend deployment workflow

**Success Criteria:**
*   Both erosion methods work independently and in combination.
*   User can observe realistic terrain aging (sharp peaks → rounded hills).
*   Deployment failure strategy documented and implemented.

---

### **Iteration 5: Performance Optimization & Parallel Execution**
**Goal:** Optimize simulation for high-resolution grids and multi-core CPUs.

**Backend Deliverables:**
*   Add OpenMP parallelization to simulation loops.
*   Implement SIMD-optimized stencil operations for neighbor lookups.
*   Add adaptive LOD (Level of Detail) system for large grids.
*   Integrate Google Benchmark into CI pipeline for regression tracking.

**Frontend Deliverables:**
*   Support for high-resolution terrains (512×512, 1024×1024).
*   Dynamic LOD rendering in R3F (lower detail for distant regions).
*   Performance profiler overlay (FPS, CPU usage, memory consumption).

**Tasks:**

**Delivery Block 1: Multi-threading Parallelization**
- [ ] **CORE-032:** Add OpenMP pragmas to main simulation loops
- [ ] **CORE-033:** Implement grid partitioning for thread distribution
- [ ] **TEST-010:** Verify linear scaling with thread count (1-8 cores)

**Delivery Block 2: SIMD Optimizations**
- [ ] **CORE-034:** Add SIMD intrinsics for height calculations (AVX/SSE)
- [ ] **CORE-035:** Optimize memory access patterns (cache locality)
- [ ] **TEST-012:** Validate SIMD calculations match scalar results

**Delivery Block 3: Memory & Allocation Optimizations**
- [ ] **CORE-041:** Optimize particle allocation (object pools)
- [ ] **CORE-040:** Profile with Valgrind/perf for hotspot identification

**Delivery Block 4: LOD System (Backend)**
- [ ] **CORE-036:** Implement quadtree LOD structure
- [ ] **CORE-037:** Add distance-based resolution switching

**Delivery Block 5: High-Resolution Support (Frontend)**
- [ ] **WEB-033:** Add resolution selector (256, 512, 1024)
- [ ] **WEB-034:** Implement R3F LOD components
- [ ] **WEB-035:** Add distance culling for far terrain chunks
- [ ] **TEST-011:** Test 1024×1024 grid at 15+ FPS

**Delivery Block 6: Performance Monitoring UI**
- [ ] **WEB-036:** Create PerformanceProfiler overlay component
- [ ] **WEB-037:** Display FPS counter (real-time)
- [ ] **WEB-038:** Add CPU/GPU usage metrics (if available)
- [ ] **WEB-039:** Show memory consumption tracker
- [ ] **WEB-040:** Implement performance graph (historical data)

**Delivery Block 7: CI Integration & Documentation**
- [ ] **CORE-038:** Write scalability benchmarks (1-16 threads)
- [ ] **CORE-039:** Add benchmark regression checks to CI
- [ ] **DOC-005:** Document performance tuning guidelines

**Success Criteria:**
*   Simulation achieves near-linear scaling with thread count.
*   1024×1024 grid runs at interactive frame rates (15+ FPS).
*   No performance regressions detected in CI benchmarks.

---

### **Iteration 6: Preset Library & Export Features**
**Goal:** Add user convenience features for saving, loading, and sharing terrains.

**Backend Deliverables:**
*   Implement heightmap serialization (save/load from disk).
*   Add preset configuration system (JSON-based parameter templates).

**Frontend Deliverables:**
*   Preset library UI:
    *   Thumbnails of pre-configured terrains (Canyon, Mountain, Coastal).
    *   One-click load functionality.
*   Export features:
    *   Download heightmap as PNG/EXR.
    *   Export simulation parameters as JSON.
    *   Share link generation (URL-encoded parameters).

**Tasks:**

**Delivery Block 1: Heightmap Serialization Core**
- [ ] **CORE-042:** Implement Heightmap serialization to binary format
- [ ] **CORE-047:** Write unit tests for serialization

**Delivery Block 2: Export Formats (PNG/EXR)**
- [ ] **CORE-043:** Add PNG export (heightmap as grayscale image)
- [ ] **CORE-044:** Implement EXR export (HDR elevation data)
- [ ] **API-011:** Create /export endpoint (supports PNG/EXR/JSON)
- [ ] **TEST-013:** Verify exported heightmaps load correctly in Blender

**Delivery Block 3: Preset System Backend**
- [ ] **CORE-045:** Create JSON schema for preset configurations
- [ ] **CORE-046:** Add preset loader/validator
- [ ] **API-012:** Add /presets endpoint (list available presets)
- [ ] **API-013:** Implement /load-preset endpoint
- [ ] **TEST-014:** Test JSON parameter round-trip (save → load)

**Delivery Block 4: Advanced Performance Optimization** (Deferred from Iteration 3.5)
- [ ] **PERF-001:** Custom cache headers for API responses (Cache-Control, ETag, conditional requests)
- [ ] **PERF-002:** CDN asset optimization (compression, cache strategies, static asset fingerprinting)
- [ ] **PERF-003:** WebSocket performance testing (concurrent connections, message throughput, latency profiling)

**Delivery Block 5: WebAssembly Exploration** (Optional - Deferred from Iteration 3.5)
- [ ] **WASM-001:** Compile C++ erosion to WebAssembly (Emscripten)
- [ ] **WASM-002:** JavaScript wrapper for WASM module
- [ ] **WASM-003:** Deploy to Cloudflare Workers
- [ ] **WASM-004:** Performance comparison: Native vs WASM

**Delivery Block 6: Preset Library UI**
- [ ] **WEB-041:** Create PresetLibrary UI component
- [ ] **WEB-042:** Design preset cards with thumbnails
- [ ] **WEB-043:** Add preset search/filter functionality
- [ ] **WEB-044:** Implement one-click load button
- [ ] **WEB-050:** Add preset saving dialog (user-created presets)

**Delivery Block 5: Export Panel UI**
- [ ] **WEB-045:** Create ExportPanel UI component
- [ ] **WEB-046:** Add format selector (PNG/EXR/JSON)
- [ ] **WEB-047:** Implement download functionality

**Delivery Block 6: Share & Collaboration Features**
- [ ] **WEB-048:** Add share link generator (URL encoding)
- [ ] **WEB-049:** Implement clipboard copy for share links
- [ ] **TEST-015:** Validate share links restore exact simulation state

**Delivery Block 7: Documentation**
- [ ] **DOC-006:** Document export formats and preset structure

**Success Criteria:**
*   User can save and restore simulation sessions.
*   Presets provide quick-start templates for experimentation.
*   Exported heightmaps are compatible with external 3D tools (Blender, Unity).

---

### **Future Iterations (Roadmap Extensions)**

*   **Iteration 7:** Tectonic deformation (uplift, folding, fault lines).
*   **Iteration 8:** Interactive sculpting tools (raise/lower, smooth, flatten brushes).
*   **Iteration 9:** Real-world data import (GeoTIFF, DEM files).
*   **Iteration 10:** Advanced rendering (PBR materials, atmospheric effects, shadows).
*   **Iteration 11:** Multiplayer/collaborative editing (real-time shared simulations).
*   **Iteration 12:** Machine learning integration (erosion pattern prediction, terrain generation from text prompts).

---

**Iteration Principles:**
*   Each iteration is fully tested and deployable.
*   CI/CD pipeline validates all changes before merging.
*   User feedback informs priority adjustments between iterations.
*   Technical debt is addressed incrementally (no "big bang" refactors).